import pandas as pd  # For data manipulation and analysisimport scipy.stats as stats  # For statistical functionsimport os  # For file and directory operationsimport argparse  # For command-line argument parsingimport tqdm  # For progress bar displayfrom typing import List, Tuple, Optionaldef load_query(query_file: str, query_membership_type: str) -> pd.DataFrame:    '''Load and clean query data from a file.'''    if not os.path.isfile(query_file):        raise FileNotFoundError(f"Query file '{query_file}' does not exist.")        query_df = pd.read_csv(query_file, sep='\t')        # Check if required columns are present    if 'Ensembl_ID' not in query_df.columns or query_membership_type not in query_df.columns:        raise ValueError(f"Query file must contain 'Ensembl_ID' and '{query_membership_type}' columns.")        query_df = (query_df                 .dropna()                 .rename(columns={query_membership_type: 'Query_Membership'}))        return query_df  # Return the cleaned query DataFramedef load_pathways(pathway_file: str, pathway_membership_type: str) -> pd.DataFrame:    '''Load and aggregate pathway data from a file.'''    if not os.path.isfile(pathway_file):        raise FileNotFoundError(f"Pathway file '{pathway_file}' does not exist.")        pathway_df = pd.read_csv(        pathway_file,        sep='\t',        usecols=['Pathway_Name', 'Description', 'Ensembl_ID', pathway_membership_type],        dtype={'Ensembl_ID': str, pathway_membership_type: float}    )    # Check if required columns are present    if 'Pathway_Name' not in pathway_df.columns or 'Description' not in pathway_df.columns or pathway_membership_type not in pathway_df.columns:        raise ValueError(f"Pathway file must contain 'Pathway_Name', 'Description', and '{pathway_membership_type}' columns.")        pathway_df = (pathway_df                   .dropna()                   .rename(columns={pathway_membership_type: 'Pathway_Membership'})                   .groupby('Pathway_Name')                   .agg({                       'Description': 'first',  # Take the first description per pathway                       'Ensembl_ID': list,  # Store Ensembl IDs as lists                       'Pathway_Membership': list  # Store memberships as lists                   })                   .reset_index())        return pathway_df  # Return the cleaned pathway DataFramedef hypergeometric_test(query_genes: List[str], pathway_genes: List[str], universe_size: int) -> Tuple[int, float]:    '''Perform a hypergeometric test to find p-value for gene overlap.'''    if universe_size <= 0:        raise ValueError("Universe size must be greater than zero.")    if not query_genes or not pathway_genes:        return 0, 1.0  # Return zero overlap and p-value of 1 if no genes        # Calculate the intersection of query and pathway genes    overlap_genes = set(query_genes).intersection(pathway_genes)    overlap_size = len(overlap_genes)  # Size of overlap        # Perform the hypergeometric test    query_size = len(query_genes)    pathway_size = len(pathway_genes)    p_value = stats.hypergeom.sf(overlap_size - 1, universe_size, pathway_size, query_size)        return overlap_size, p_value  # Return overlap size and p-valuedef standard_ora_compute_stats(pathway: pd.Series, query_df: pd.DataFrame, universe_size: int) -> Tuple[int, float]:    '''Compute overlap size and p-value for a given pathway.'''    query_genes = query_df['Ensembl_ID'].tolist()  # List of all query genes    query_genes_filtered = query_df[query_df['Query_Membership'] == 1]['Ensembl_ID'].tolist()  # Filtered by membership        # Extract pathway genes and memberships    pathway_genes = pathway['Ensembl_ID']    pathway_memberships = pathway['Pathway_Membership']        # Filter pathway genes by membership    pathway_genes_filtered = [        gene for gene, membership in zip(pathway_genes, pathway_memberships)        if membership == 1 and gene in query_genes    ]        # Compute overlap size and p-value using the hypergeometric test    overlap_size, p_value = hypergeometric_test(query_genes_filtered, pathway_genes_filtered, universe_size)        return overlap_size, p_value  # Return the resultsdef standard_ora(    query_file: str,    pathway_file: str,    query_membership_type: str = 'Crisp_Membership',    pathway_membership_type: str = 'Crisp_Membership',    output_path: Optional[str] = None,    dataset_name: str = '',    pathway_ids: Optional[List[str]] = None) -> pd.DataFrame:    '''Perform standard Over-Representation Analysis (ORA).'''    query_df = load_query(query_file, query_membership_type)  # Load query data    pathway_df = load_pathways(pathway_file, pathway_membership_type)  # Load pathway data        # Filter pathways by IDs if provided    if pathway_ids is not None:        pathway_df = pathway_df[pathway_df['Pathway_Name'].isin(pathway_ids)]        universe_size = len(query_df)  # Total number of genes in the query    num_pathways = len(pathway_df)  # Total number of pathways        results = []  # Initialize results list    # Iterate over each pathway and compute stats    for _, pathway in tqdm.tqdm(pathway_df.iterrows(), total=num_pathways, desc="Processing Pathways"):        overlap_size, p_value = standard_ora_compute_stats(pathway, query_df, universe_size)        results.append({            'Pathway_Name': pathway['Pathway_Name'],            'Description': pathway['Description'],            'Observed_Intersection': overlap_size,            'p_value': p_value        })        # Create DataFrame from results and rank pathways by p-value    results_df = pd.DataFrame(results).sort_values('p_value').reset_index(drop=True)    results_df['Rank'] = results_df['p_value'].rank(method='min').astype(int)        # Save results to CSV if output path is provided    if output_path:        results_folder = os.path.join(output_path, dataset_name)        os.makedirs(results_folder, exist_ok=True)        results_file_name = f"standard_ora_results_{dataset_name}_{query_membership_type}_{pathway_membership_type}.csv"        results_df.to_csv(os.path.join(results_folder, results_file_name), index=False)        standard_ora_results = results_df  # Assign to a variable before returning    return standard_ora_results  # Return the final results DataFramedef standard_ora_main():    """Parse command-line arguments and execute the standard_ora function."""    parser = argparse.ArgumentParser(description="Run standard ORA analysis.")    parser.add_argument('-q', '--query_file', required=True, help="Path to the query file.")    parser.add_argument('-p', '--pathway_file', required=True, help="Path to the pathway file.")    parser.add_argument('-q_name', '--query_membership_type', default='Crisp_Membership', help="Query membership type.")    parser.add_argument('-p_name', '--pathway_membership_type', default='Crisp_Membership', help="Pathway membership type.")    parser.add_argument('-o', '--output_path', default=None, help="Output directory path.")    parser.add_argument('-d', '--dataset_name', default='', help="Dataset name for output files.")    parser.add_argument('--pathway_ids', nargs='+', help="List of specific pathway IDs to include.")    args = parser.parse_args()    # Execute the standard ORA function with the parsed arguments    standard_ora(        query_file=args.query_file,        pathway_file=args.pathway_file,        query_membership_type=args.query_membership_type,        pathway_membership_type=args.pathway_membership_type,        output_path=args.output_path,        dataset_name=args.dataset_name,        pathway_ids=args.pathway_ids  # Pass the list of pathway IDs    )if __name__ == "__main__":    # standard_ora_main()    # Uncomment the previous line and comment the following lines to run from the command line    # Direct invocation for IDE usage    query_file = "/Users/piamozdzanowski/VU/Fuzzy_Gene_Sets/data_old/single_cell/HIV_E-GEOD-111727_membership.csv"    pathway_file = '../../../data/pathways/KEGG/KEGG_2022_pathway_memberships.tsv'    query_membership_type = 'Crisp_Membership'    pathway_membership_type = 'Crisp_Membership'    output_path = "/Users/piamozdzanowski/VU/Fuzzy_Gene_Sets/data/ORA_output/infection/HIV"    dataset_name = "HIV_E-GEOD-111727"    pathway_ids = None    standard_ora_results = standard_ora(        query_file=query_file,        pathway_file=pathway_file,        query_membership_type=query_membership_type,        pathway_membership_type=pathway_membership_type,        output_path=output_path,        dataset_name=dataset_name,        pathway_ids=pathway_ids    )